/**
 * @knowgraph
 * type: module
 * description: CLI command to export knowledge graph as .cursorrules or markdown
 * owner: knowgraph-cli
 * status: experimental
 * tags: [cli, command, export, cursorrules]
 * context:
 *   business_goal: Enable AI coding tools beyond MCP to leverage KnowGraph data
 *   domain: cli
 */
import { resolve } from 'node:path';
import { existsSync, writeFileSync } from 'node:fs';
import type { Command } from 'commander';
import chalk from 'chalk';
import {
  createDatabaseManager,
  createQueryEngine,
} from '@knowgraph/core';
import type { StoredEntity } from '@knowgraph/core';

type ExportFormat = 'cursorrules' | 'markdown';

interface ExportCommandOptions {
  readonly format: ExportFormat;
  readonly output?: string;
}

interface OwnerGroup {
  readonly owner: string;
  readonly entities: readonly StoredEntity[];
}

interface GroupedByType {
  readonly entityType: string;
  readonly entities: readonly StoredEntity[];
}

function getBusinessGoal(entity: StoredEntity): string | undefined {
  const metadata = entity.metadata as Record<string, unknown>;
  const context = metadata.context as
    | Record<string, unknown>
    | undefined;
  if (!context) return undefined;
  const goal = context.business_goal;
  return typeof goal === 'string' ? goal : undefined;
}

function groupByOwner(
  entities: readonly StoredEntity[],
): readonly OwnerGroup[] {
  const ownerMap = new Map<string, StoredEntity[]>();

  for (const entity of entities) {
    const owner = entity.owner ?? '';
    const existing = ownerMap.get(owner) ?? [];
    ownerMap.set(owner, [...existing, entity]);
  }

  const groups: OwnerGroup[] = [];
  for (const [owner, groupEntities] of ownerMap) {
    if (owner !== '') {
      groups.push({ owner, entities: groupEntities });
    }
  }

  // Sort owner groups alphabetically
  groups.sort((a, b) => a.owner.localeCompare(b.owner));

  // Add unowned group at the end if it exists
  const unowned = ownerMap.get('');
  if (unowned && unowned.length > 0) {
    groups.push({ owner: '', entities: unowned });
  }

  return groups;
}

function groupByEntityType(
  entities: readonly StoredEntity[],
): readonly GroupedByType[] {
  const typeMap = new Map<string, StoredEntity[]>();

  for (const entity of entities) {
    const existing = typeMap.get(entity.entityType) ?? [];
    typeMap.set(entity.entityType, [...existing, entity]);
  }

  const groups: GroupedByType[] = [];
  for (const [entityType, groupEntities] of typeMap) {
    groups.push({ entityType, entities: groupEntities });
  }

  return groups.sort((a, b) => a.entityType.localeCompare(b.entityType));
}

function formatEntityLine(entity: StoredEntity): string {
  const location = `${entity.filePath}:${entity.line}`;
  return `- **${entity.name}** (${entity.entityType}) - ${entity.description} [${location}]`;
}

function formatEntityDetails(entity: StoredEntity): string {
  const lines: string[] = [];
  const status = entity.status ?? 'unknown';

  lines.push(`### ${entity.name} (${entity.entityType}) - ${status}`);
  lines.push(`**File:** ${entity.filePath}:${entity.line}`);
  lines.push(`**Owner:** ${entity.owner ?? 'unowned'}`);
  lines.push(`**Description:** ${entity.description}`);

  if (entity.tags.length > 0) {
    lines.push(`**Tags:** ${entity.tags.join(', ')}`);
  }

  const businessGoal = getBusinessGoal(entity);
  if (businessGoal) {
    lines.push(`**Business Goal:** ${businessGoal}`);
  }

  return lines.join('\n');
}

function getFormatHeader(format: ExportFormat): string {
  if (format === 'markdown') {
    return [
      '# Project Knowledge Graph',
      '> Auto-generated by KnowGraph. Do not edit manually.',
      '> Regenerate with: knowgraph export --format markdown',
      '',
      '> This file provides AI-readable context about the codebase.',
    ].join('\n');
  }

  return [
    '# Project Knowledge Graph',
    '> Auto-generated by KnowGraph. Do not edit manually.',
    '> Regenerate with: knowgraph export --format cursorrules',
  ].join('\n');
}

export function formatExport(
  entities: readonly StoredEntity[],
  format: ExportFormat,
): string {
  const sections: string[] = [];

  // Header
  sections.push(getFormatHeader(format));

  if (entities.length === 0) {
    sections.push('## Architecture Overview');
    sections.push(
      'This project contains 0 annotated code entities. Run `knowgraph index .` to populate the knowledge graph.',
    );
    return sections.join('\n\n');
  }

  // Architecture Overview
  const ownerGroups = groupByOwner(entities);
  const namedOwners = ownerGroups.filter((g) => g.owner !== '');
  const ownerCount = namedOwners.length;

  sections.push('## Architecture Overview');
  sections.push(
    `This project contains ${entities.length} annotated code entities across ${ownerCount} owners.`,
  );

  // Code Ownership section
  sections.push('## Code Ownership');

  for (const group of ownerGroups) {
    if (group.owner === '') continue;

    const ownerLines: string[] = [];
    ownerLines.push(`### ${group.owner}`);

    const byType = groupByEntityType(group.entities);
    for (const typeGroup of byType) {
      for (const entity of typeGroup.entities) {
        ownerLines.push(formatEntityLine(entity));
      }
    }

    sections.push(ownerLines.join('\n'));
  }

  // Unowned entities
  const unownedGroup = ownerGroups.find((g) => g.owner === '');
  if (unownedGroup) {
    const unownedLines: string[] = [];
    unownedLines.push('## Unowned Entities');
    for (const entity of unownedGroup.entities) {
      unownedLines.push(formatEntityLine(entity));
    }
    sections.push(unownedLines.join('\n'));
  }

  // Entity Details section
  sections.push('## Entity Details');

  for (const entity of entities) {
    sections.push(formatEntityDetails(entity));
  }

  return sections.join('\n\n');
}

function getDefaultOutputFile(format: ExportFormat): string {
  return format === 'cursorrules' ? '.cursorrules' : 'CODEBASE.md';
}

function runExport(
  targetPath: string,
  options: ExportCommandOptions,
): void {
  const absPath = resolve(targetPath);
  const dbPath = resolve(absPath, '.knowgraph', 'knowgraph.db');

  if (!existsSync(dbPath)) {
    console.error(
      chalk.red(
        `Error: Database not found at ${dbPath}. Run 'knowgraph index ${targetPath}' first.`,
      ),
    );
    process.exitCode = 1;
    return;
  }

  const format = options.format;
  if (format !== 'cursorrules' && format !== 'markdown') {
    console.error(
      chalk.red(
        `Error: Invalid format '${format}'. Use 'cursorrules' or 'markdown'.`,
      ),
    );
    process.exitCode = 1;
    return;
  }

  try {
    const dbManager = createDatabaseManager(dbPath);
    try {
      const queryEngine = createQueryEngine(dbManager);
      const result = queryEngine.search({ query: '', limit: 10000 });
      const entities = result.entities;

      const content = formatExport(entities, format);

      const outputFile = resolve(
        absPath,
        options.output ?? getDefaultOutputFile(format),
      );
      writeFileSync(outputFile, content, 'utf-8');

      if (entities.length === 0) {
        console.log(
          chalk.yellow(
            `Warning: No entities found in the index. Exported empty template to ${outputFile}`,
          ),
        );
      } else {
        console.log(
          chalk.green(
            `Exported ${entities.length} entities to ${outputFile}`,
          ),
        );
      }
    } finally {
      dbManager.close();
    }
  } catch (err) {
    console.error(
      chalk.red(
        `Error: ${err instanceof Error ? err.message : String(err)}`,
      ),
    );
    process.exitCode = 1;
  }
}

export function registerExportCommand(program: Command): void {
  program
    .command('export [path]')
    .description(
      'Export knowledge graph as .cursorrules or markdown file',
    )
    .option(
      '--format <format>',
      'Output format (cursorrules|markdown)',
      'cursorrules',
    )
    .option('--output <file>', 'Output file path')
    .action((path: string | undefined, opts: ExportCommandOptions) => {
      runExport(path ?? '.', opts);
    });
}
