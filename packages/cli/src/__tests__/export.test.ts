import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import type { StoredEntity } from '@knowgraph/core';
import { formatExport } from '../commands/export.js';

function createEntity(overrides: Partial<StoredEntity> = {}): StoredEntity {
  return {
    id: 'test-id-1',
    filePath: 'src/utils/helpers.ts',
    name: 'formatDate',
    entityType: 'function',
    description: 'Formats a date to ISO string',
    rawDocstring: null,
    signature: 'formatDate(date: Date): string',
    parent: null,
    language: 'typescript',
    line: 10,
    column: 0,
    owner: 'utils-team',
    status: 'stable',
    metadata: {
      type: 'function',
      description: 'Formats a date to ISO string',
    },
    tags: ['utility', 'date'],
    links: [],
    fileHash: null,
    createdAt: '2024-01-01T00:00:00Z',
    updatedAt: '2024-01-01T00:00:00Z',
    ...overrides,
  };
}

describe('formatExport', () => {
  describe('empty index', () => {
    it('returns a template with zero entities message for cursorrules format', () => {
      const result = formatExport([], 'cursorrules');

      expect(result).toContain('# Project Knowledge Graph');
      expect(result).toContain('Auto-generated by KnowGraph');
      expect(result).toContain('0 annotated code entities');
      expect(result).toContain('knowgraph index .');
    });

    it('returns a template with zero entities message for markdown format', () => {
      const result = formatExport([], 'markdown');

      expect(result).toContain('# Project Knowledge Graph');
      expect(result).toContain('0 annotated code entities');
      expect(result).toContain('--format markdown');
    });
  });

  describe('header format', () => {
    it('includes cursorrules regeneration command for cursorrules format', () => {
      const result = formatExport([createEntity()], 'cursorrules');

      expect(result).toContain(
        'Regenerate with: knowgraph export --format cursorrules',
      );
    });

    it('includes markdown regeneration command for markdown format', () => {
      const result = formatExport([createEntity()], 'markdown');

      expect(result).toContain(
        'Regenerate with: knowgraph export --format markdown',
      );
      expect(result).toContain('AI-readable context');
    });

    it('includes do not edit warning', () => {
      const result = formatExport([createEntity()], 'cursorrules');

      expect(result).toContain('Do not edit manually');
    });
  });

  describe('architecture overview', () => {
    it('shows correct entity count', () => {
      const entities = [
        createEntity({ id: '1', name: 'fn1' }),
        createEntity({ id: '2', name: 'fn2' }),
        createEntity({ id: '3', name: 'fn3' }),
      ];

      const result = formatExport(entities, 'cursorrules');

      expect(result).toContain('3 annotated code entities');
    });

    it('shows correct owner count excluding unowned', () => {
      const entities = [
        createEntity({ id: '1', name: 'fn1', owner: 'team-a' }),
        createEntity({ id: '2', name: 'fn2', owner: 'team-b' }),
        createEntity({ id: '3', name: 'fn3', owner: null }),
      ];

      const result = formatExport(entities, 'cursorrules');

      expect(result).toContain('across 2 owners');
    });
  });

  describe('code ownership grouping', () => {
    it('groups entities by owner', () => {
      const entities = [
        createEntity({
          id: '1',
          name: 'fnA',
          owner: 'team-alpha',
          description: 'Alpha function',
        }),
        createEntity({
          id: '2',
          name: 'fnB',
          owner: 'team-beta',
          description: 'Beta function',
        }),
      ];

      const result = formatExport(entities, 'cursorrules');

      expect(result).toContain('### team-alpha');
      expect(result).toContain('### team-beta');
    });

    it('sorts owner groups alphabetically', () => {
      const entities = [
        createEntity({ id: '1', name: 'fnZ', owner: 'z-team' }),
        createEntity({ id: '2', name: 'fnA', owner: 'a-team' }),
      ];

      const result = formatExport(entities, 'cursorrules');

      const aTeamPos = result.indexOf('### a-team');
      const zTeamPos = result.indexOf('### z-team');
      expect(aTeamPos).toBeLessThan(zTeamPos);
    });

    it('formats entity lines with name, type, description, and location', () => {
      const entity = createEntity({
        name: 'MyService',
        entityType: 'service',
        description: 'Main service',
        filePath: 'src/service.ts',
        line: 42,
      });

      const result = formatExport([entity], 'cursorrules');

      expect(result).toContain(
        '- **MyService** (service) - Main service [src/service.ts:42]',
      );
    });
  });

  describe('unowned entities', () => {
    it('includes an Unowned Entities section for entities with null owner', () => {
      const entities = [
        createEntity({ id: '1', name: 'ownedFn', owner: 'team-a' }),
        createEntity({ id: '2', name: 'orphanFn', owner: null }),
      ];

      const result = formatExport(entities, 'cursorrules');

      expect(result).toContain('## Unowned Entities');
      expect(result).toContain('**orphanFn**');
    });

    it('does not include Unowned Entities section when all entities have owners', () => {
      const entities = [
        createEntity({ id: '1', name: 'fn1', owner: 'team-a' }),
        createEntity({ id: '2', name: 'fn2', owner: 'team-b' }),
      ];

      const result = formatExport(entities, 'cursorrules');

      expect(result).not.toContain('## Unowned Entities');
    });

    it('handles all entities being unowned', () => {
      const entities = [
        createEntity({ id: '1', name: 'orphan1', owner: null }),
        createEntity({ id: '2', name: 'orphan2', owner: null }),
      ];

      const result = formatExport(entities, 'cursorrules');

      expect(result).toContain('## Unowned Entities');
      expect(result).toContain('across 0 owners');
      expect(result).toContain('**orphan1**');
      expect(result).toContain('**orphan2**');
    });
  });

  describe('entity details', () => {
    it('includes detail sections for each entity', () => {
      const entity = createEntity({
        name: 'UserService',
        entityType: 'service',
        status: 'stable',
        filePath: 'src/users.ts',
        line: 5,
        owner: 'auth-team',
        description: 'Manages user accounts',
        tags: ['auth', 'users'],
      });

      const result = formatExport([entity], 'cursorrules');

      expect(result).toContain('### UserService (service) - stable');
      expect(result).toContain('**File:** src/users.ts:5');
      expect(result).toContain('**Owner:** auth-team');
      expect(result).toContain('**Description:** Manages user accounts');
      expect(result).toContain('**Tags:** auth, users');
    });

    it('shows unknown status when status is null', () => {
      const entity = createEntity({ status: null });

      const result = formatExport([entity], 'cursorrules');

      expect(result).toContain('- unknown');
    });

    it('shows unowned when owner is null in details', () => {
      const entity = createEntity({ owner: null });

      const result = formatExport([entity], 'cursorrules');

      expect(result).toContain('**Owner:** unowned');
    });

    it('omits tags line when entity has no tags', () => {
      const entity = createEntity({ tags: [] });

      const result = formatExport([entity], 'cursorrules');

      // The details section should not have a Tags line
      const detailsSection = result.split('## Entity Details')[1];
      expect(detailsSection).not.toContain('**Tags:**');
    });

    it('includes business goal from extended metadata', () => {
      const entity = createEntity({
        metadata: {
          type: 'function',
          description: 'A function',
          context: { business_goal: 'Improve user retention' },
        },
      });

      const result = formatExport([entity], 'cursorrules');

      expect(result).toContain(
        '**Business Goal:** Improve user retention',
      );
    });

    it('omits business goal when not present in metadata', () => {
      const entity = createEntity({
        metadata: {
          type: 'function',
          description: 'A function',
        },
      });

      const result = formatExport([entity], 'cursorrules');

      expect(result).not.toContain('**Business Goal:**');
    });

    it('omits business goal when context exists but business_goal is missing', () => {
      const entity = createEntity({
        metadata: {
          type: 'function',
          description: 'A function',
          context: { funnel_stage: 'acquisition' },
        },
      });

      const result = formatExport([entity], 'cursorrules');

      expect(result).not.toContain('**Business Goal:**');
    });
  });

  describe('multiple entity types within owner', () => {
    it('groups entities by type within an owner section', () => {
      const entities = [
        createEntity({
          id: '1',
          name: 'MyClass',
          entityType: 'class',
          owner: 'core-team',
        }),
        createEntity({
          id: '2',
          name: 'myFunction',
          entityType: 'function',
          owner: 'core-team',
        }),
        createEntity({
          id: '3',
          name: 'MyModule',
          entityType: 'module',
          owner: 'core-team',
        }),
      ];

      const result = formatExport(entities, 'cursorrules');

      // All should appear under core-team
      expect(result).toContain('### core-team');
      expect(result).toContain('**MyClass** (class)');
      expect(result).toContain('**myFunction** (function)');
      expect(result).toContain('**MyModule** (module)');
    });
  });

  describe('section structure', () => {
    it('contains all required sections', () => {
      const entity = createEntity();
      const result = formatExport([entity], 'cursorrules');

      expect(result).toContain('# Project Knowledge Graph');
      expect(result).toContain('## Architecture Overview');
      expect(result).toContain('## Code Ownership');
      expect(result).toContain('## Entity Details');
    });

    it('returns a valid string with no undefined or null text', () => {
      const entities = [
        createEntity({ id: '1', owner: 'team-a' }),
        createEntity({ id: '2', owner: null, tags: [], status: null }),
      ];

      const result = formatExport(entities, 'cursorrules');

      expect(result).not.toContain('undefined');
      expect(result).not.toContain('null');
    });
  });
});

describe('registerExportCommand', () => {
  it('registers the export command on a Commander program', async () => {
    const { registerExportCommand } = await import(
      '../commands/export.js'
    );
    const { Command } = await import('commander');
    const program = new Command();

    registerExportCommand(program);

    const exportCmd = program.commands.find(
      (c) => c.name() === 'export',
    );
    expect(exportCmd).toBeDefined();
    expect(exportCmd!.description()).toContain('Export');
  });
});

describe('runExport integration', () => {
  let consoleLogSpy: ReturnType<typeof vi.spyOn>;
  let consoleErrorSpy: ReturnType<typeof vi.spyOn>;
  let originalExitCode: number | undefined;

  beforeEach(() => {
    consoleLogSpy = vi
      .spyOn(console, 'log')
      .mockImplementation(() => {});
    consoleErrorSpy = vi
      .spyOn(console, 'error')
      .mockImplementation(() => {});
    originalExitCode = process.exitCode;
    process.exitCode = undefined;
  });

  afterEach(() => {
    consoleLogSpy.mockRestore();
    consoleErrorSpy.mockRestore();
    process.exitCode = originalExitCode;
  });

  it('reports error when database does not exist', async () => {
    const { registerExportCommand } = await import(
      '../commands/export.js'
    );
    const { Command } = await import('commander');
    const program = new Command();
    program.exitOverride();

    registerExportCommand(program);

    const exportCmd = program.commands.find(
      (c) => c.name() === 'export',
    );
    exportCmd!.parseAsync([
      'node',
      'knowgraph',
      '/nonexistent/path/that/does/not/exist',
    ]);

    // Allow microtask to complete
    await new Promise((resolve) => setTimeout(resolve, 10));

    expect(process.exitCode).toBe(1);
    expect(consoleErrorSpy).toHaveBeenCalled();
    const errorArg = consoleErrorSpy.mock.calls[0]?.[0] ?? '';
    expect(errorArg).toContain('Database not found');
  });
});
